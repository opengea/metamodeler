// standard global variables
var container, scene, camera, mouse, renderer, controls, stats, objects;
var keyboard = new THREEx.KeyboardState();

// custom global variables
var cube;
var projector, mouse = { x: 0, y: 0 }, INTERSECTED;
var sprite1;
var canvas1, context1, texture1;

//global
var torusgeometry;
var torusmaterial;
var torus;
var geometrySphere;
var materialSphere;
var sphere;
var tropic_can;
var tropic_cap;
var equador;
var globalium=[]; // arrays amb objectes

//objects
var objects=[]; //objects to click
var cat=[]; //labels in the model
var cat2=[];

raycaster = new THREE.Raycaster();

class CustomTrackballControls extends THREE.TrackballControls {
    constructor(object, domElement) {
        super(object, domElement);
        this.minPolarAngle = Math.PI / 2; // Prevent moving up
        this.maxPolarAngle = Math.PI / 2; // Prevent moving down
    }

    update() {
        const offset = new THREE.Vector3();
        offset.copy(this.object.position).sub(this.target);
        const spherical = new THREE.Spherical();
        spherical.setFromVector3(offset);

        // Clamp polar angle
        spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, spherical.phi));

        offset.setFromSpherical(spherical);
        this.object.position.copy(this.target).add(offset);
        this.object.lookAt(this.target);

        super.update();
    }
}

function init(mobile) 
{

        // SCENE
        scene = new THREE.Scene();

        // CAMERA
        var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
        var VIEW_ANGLE = 20, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
        camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);

        scene.add(camera);
        camera.position.set(90,-1460,0);
        camera.lookAt(scene.position);  

        // RENDERER
        if ( Detector.webgl )
                renderer = new THREE.WebGLRenderer( {antialias:true} );
        else
                renderer = new THREE.CanvasRenderer(); 
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container = document.getElementById( 'ThreeJS' );
        container.appendChild( renderer.domElement );

        // EVENTS
        THREEx.WindowResize(renderer, camera);
        THREEx.FullScreen.bindKey({ charCode : 'f'.charCodeAt(0) }); // f=fullscreen

        renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );

	//TROPICS I EQUADOR
	ecuador_geo = new THREE.CircleGeometry(100,8);
	ecuador_mat = new THREE.MeshBasicMaterial({ color: 0x111111, wireframe:true });
	ecuador = new THREE.Mesh(ecuador_geo, ecuador_mat);
	scene.add(ecuador);
	ecuador.position.set(0,0,0);
	ecuador.rotation.y=300.02;//Math.PI / 2;

        ecuador_geo = new THREE.CircleGeometry(80,8);
        ecuador_mat = new THREE.MeshBasicMaterial({ color: 0x111111, wireframe:true });
        tropic_cap = new THREE.Mesh(ecuador_geo, ecuador_mat);
        scene.add(tropic_cap);
        tropic_cap.position.set(-60,0,0);
	tropic_cap.rotation.y=300.02;

        ecuador_geo = new THREE.CircleGeometry(80,8);
        ecuador_mat = new THREE.MeshBasicMaterial({ color: 0x111111, wireframe:true });
        tropic_can = new THREE.Mesh(ecuador_geo, ecuador_mat);
        scene.add(tropic_can);
	tropic_can.position.set(60,0,0);
        tropic_can.rotation.y=300.02;
	
	// ROTATE CAM
	window.addEventListener( 'keydown', onDocumentKeyDown, false );

        // CONTROLS
        controls = new THREE.TrackballControls( camera,container );
	controls = new CustomTrackballControls( camera,container );


        if (mobile) { controls.rotateSpeed = 2.0; } else {  controls.rotateSpeed = 10.0; }
        controls.zoomSpeed = 0.05;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = true; //false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ]; //A, S, D (http://cherrytree.at/misc/vk.htm)
        controls.addEventListener( 'change', render );

	/* dimensional axis - eixos */

	//PRA
	var geometry = new THREE.BufferGeometry();
	var vertex1 = new THREE.Vector3( -155, 0, 0 ); var vertex2 = new THREE.Vector3( 0, 0, 0 );
	var positions = new Float32Array([
	    vertex1.x, vertex1.y, vertex1.z,
    	    vertex2.x, vertex2.y, vertex2.z,
	]); 
	geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
	var material = new THREE.LineDashedMaterial({ color: 0xff5500, linewidth: 1, scale: 10, dashSize: 2, gapSize: 2, transparent: false, opacity:0.5 });
	var line = new THREE.Line( geometry, material );
	scene.add( line );

	//TEO
	var geometry = new THREE.BufferGeometry();
	var vertex1 = new THREE.Vector3( 0, 0, 0 ); var vertex2 = new THREE.Vector3( 155, 0, 0 );
        var positions = new Float32Array([
            vertex1.x, vertex1.y, vertex1.z,
            vertex2.x, vertex2.y, vertex2.z,
        ]);
	geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        var material = new THREE.LineDashedMaterial({ color: 0x0040ff, linewidth: 220, dashSize: 2, gapSize: 2 });
        var line = new THREE.Line( geometry, material );
        scene.add( line );	

	//NOU
        var geometry = new THREE.BufferGeometry();
	var vertex1 = new THREE.Vector3( 0, 0, 0 ); var vertex2 = new THREE.Vector3( 0, 155, 0 );
        var positions = new Float32Array([
            vertex1.x, vertex1.y, vertex1.z,
            vertex2.x, vertex2.y, vertex2.z,
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        //geometry.computeLineDistances();
        var material = new THREE.LineDashedMaterial({ color: 0x761ad2, dashSize: 2, gapSize: 2 });
        var line = new THREE.Line( geometry, material );
        scene.add( line );

	//FEN
        var geometry = new THREE.BufferGeometry();
	var vertex1 = new THREE.Vector3( 0, 0, 0 ); var vertex2 = new THREE.Vector3( 0, -155, 0 );
        var positions = new Float32Array([
            vertex1.x, vertex1.y, vertex1.z,
            vertex2.x, vertex2.y, vertex2.z,
        ]);
	geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        //geometry.computeLineDistances();
        var material = new THREE.LineDashedMaterial({ color: 0x43bd18, dashSize: 2, gapSize: 2 });
        var line = new THREE.Line( geometry, material );
        scene.add( line );

	//SUB
	var geometry = new THREE.BufferGeometry();
	var vertex1 = new THREE.Vector3( 0, 0, 0 ); var vertex2 = new THREE.Vector3( 0, 0, 155 );
        var positions = new Float32Array([
            vertex1.x, vertex1.y, vertex1.z,
            vertex2.x, vertex2.y, vertex2.z,
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        var material = new THREE.LineDashedMaterial({ color: 0xffaaaa, dashSize: 2, gapSize: 2, transparent: false, opacity:0.7 })
        var line = new THREE.Line( geometry, material );
        scene.add( line );

	//OBJ
	var geometry = new THREE.BufferGeometry();
	var vertex1 = new THREE.Vector3( 0, 0, 0 ); var vertex2 = new THREE.Vector3( 0, 0, -155 );
        var positions = new Float32Array([
            vertex1.x, vertex1.y, vertex1.z,
            vertex2.x, vertex2.y, vertex2.z,
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        //geometry.computeLineDistances();
        var material = new THREE.LineDashedMaterial({ color: 0x0099ff, dashSize: 2, gapSize: 2, transparent: false, opacity:0.5  });
        var line = new THREE.Line( geometry, material );
        scene.add( line );

	//PLASMA SPHERE
	geometrySphere = new THREE.SphereGeometry( 50 , 100, 100 );
	materialSphere = new THREE.MeshLambertMaterial({wireframe: true, color: 0xffffff,transparent:true,opacity:0.09});

	var materialSphere = new THREE.MeshLambertMaterial({
	    color: 0xff0000,
	    emissive: 0x000000,
	    emissiveIntensity: 0,
	    wireframe: true,
	    transparent: true,
	    opacity: 0.05,
	    flatShading: false
	});

	sphere = new THREE.Mesh( geometrySphere, materialSphere );
	scene.add( sphere );

        //NEUTRAL SPHERE
        geometrySphere = new THREE.SphereGeometry( $('#sphere_rad').val(), 126, 126 );
        materialSphere = new THREE.MeshLambertMaterial({wireframe: true, color: 0xffffff,transparent:true,opacity:0.05});

	var materialSphere = new THREE.MeshLambertMaterial({
	 color: 0xffffff,
	    emissive: 0x000000,
	    emissiveIntensity: 0,
	    wireframe: false,
	    transparent: true,
	    opacity: 0.1,
	    flatShading: false
	});

        sphere = new THREE.Mesh( geometrySphere, materialSphere );
        scene.add( sphere );

        //SPHERE MON
        geometrySphere = new THREE.SphereGeometry( 155, 180, 180 );
        materialSphere = new THREE.MeshLambertMaterial({wireframe: true, color: 0xffffff,transparent:true,opacity:0.06});

        var materialSphere = new THREE.MeshLambertMaterial({
         color: 0x0077ff,
            emissive: 0x000000,
            emissiveIntensity: 0,
            wireframe: true,
            transparent: true,
            opacity: 0.09,
            flatShading: false
        });

        sphere = new THREE.Mesh( geometrySphere, materialSphere );
        scene.add( sphere );
	
        var spritey;
}

//positioning
function situa(PT,FN,OS) {  //PT=Pra-Teo  FN=Fen-Nou OS=Obj-Sub

}

function posx(percent,relative) {
}

function posy(percent,relative) {
}
function posz(percent,relative) {
}

function toCir (x,y,z) {
}

function degInRad(deg) {
}  

function onDocumentKeyDown ( event ) {
    rot = 0.025;
    delta = 5;
    var x = camera.position.x,
        y = camera.position.y,
        z = camera.position.z;

    event = event || window.event;
    var keycode = event.keyCode;
    switch (keycode) {
        case 37: // left arrow
            camera.position.x = x * Math.cos(rot) + z * Math.sin(rot);
            camera.position.z = z * Math.cos(rot) - x * Math.sin(rot);
            break;
        case 38: // up arrow
            camera.position.z = camera.position.z - delta;
            break;
        case 39: // right arrow
            camera.position.x = x * Math.cos(rot) - z * Math.sin(rot);
            camera.position.z = z * Math.cos(rot) + x * Math.sin(rot);
            break;
        case 40: // down arrow
            camera.position.z = camera.position.z + delta;
            break;
    }
    camera.lookAt(scene.position);
}

function onDocumentMouseDown( event ) {

   var mouse = new THREE.Vector2();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    var raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera); //r70!

    var intersects = raycaster.intersectObjects(objects);
    if (intersects.length > 0) {
        document.body.style.cursor = 'pointer';
        var obj = intersects[0].object;
        var info = "<br>" + obj.data.title + " (" + obj.name + ")";//("+obj.position.x+","+obj.position.y+","+obj.position.z+")";
        if (obj.data.type != "Plasmàtica" && obj.data.type != "Mundana") { add2 = ")"; add = "NEUTRAL ("; } else { add = add2 = ""; }
        info += "<br><br>Type: " + add + obj.data.type + add2 + "</span>";
        info += "<br><br><span class='colortheme_dark'>" + obj.data.descr + "</span>";
        if (obj.data.related) info += "<br><br><span style='color:#999'><b>Afins:</b><br>" + obj.data.related + "</span>";
        $('#info').html(info);
        setTab('info');
    } else {
        document.body.style.cursor = 'default';
        $('#info').html(info);
        setTab('info');
    }

}

function setTab(panel) {
}

function set_visibility(obj,v) {
}

function set_visibility_all(v) {
}

//var particleTexture = THREE.ImageUtils.loadTexture( 'images/particle.png' );
var particleGroup = new THREE.Object3D();
var particleAttributes = { startSize: [], startPosition: [], randomness: [] };
var radiusRange = 140;
	
function loadCategories(label,data,properties) {
}

function loadCategories2(label,data,properties) {
}

function makeTextSprite( type, message, parameters )
{
}

// function for drawing rounded rectangles
function roundRect(ctx, x, y, w, h, r) 
{
}

function animate() 
{
    setTimeout( function() {
        requestAnimationFrame( animate );
    }, 1000 / 30 );
        render();               
        update();
}

function update()
{
        controls.update();
}
function render() 
{
        renderer.render( scene, camera );
}

